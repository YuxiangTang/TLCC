import numpy as np
import cv2
from .base_dataset import base_dataset
import torch
import math
import random
from utils import *
from img_aug import *

class MIX(base_dataset):
    def __init__(self, dataset_name, data_dir, mode, fold_idx, minik = 1, input_size = 512, aug_num=4, camera_trans=None, bright_occ_mode=False, blur_mode=False):
        base_dataset.__init__(self, data_dir, minik, input_size, mode)
        self.dataset_name = dataset_name
        self.camera_trans = camera_trans
        self.bright_occ_mode = bright_occ_mode
        self.blur_mode = blur_mode
        self.img_list = self.three_fold(fold_idx)
            
        self.dynamic = {'Canon1DsMkIII':16383, 'Canon600D':16383, 'FujifilmXM1':4095, 'NikonD5200':16383, \
                      'OlympusEPL6':4095, 'PanasonicGX1':4095, 'SamsungNX2000':4095, 'SonyA57':4095, \
                      'Canon5D':4095, 'Canon1D':4095, 'Canon550D':16383 }
        self.ANGLE = 60
        self.RAW_SCALE = [0.5, 1.0]
        self.JPG_SCALE = [0.5, 1.0]
        self.AUG_NUM = aug_num
        self.AUG_COLOR = 0.8
        
    def __len__(self):
        return len(self.img_list)
    
    def __getitem__(self, idx):
        # combine JPG and RAW
        img_path = self.data_dir + self.img_list[idx]
        dataset = self.img_list[idx].split('/')[1]
        # JPG Preprocess Road
        if dataset in ['Place205']:  
            img = np.load(img_path).astype(np.float32)[:,:,::-1]
            img = img / np.max(img)
            R = remove_gamma(img)
            if self.mode == 'train':
                if self.camera_trans == 'all':
                    random_num = np.random.randint(0, 11)
                    camera = self.camera_mode[random_num] 
                else:
                    camera = self.camera_trans
                    if camera == None:
                        camera = 'JPG'    
            else:
                camera = 'JPG'      
            R = sRGB2Camera(R, camera)
                
            R = R * 65535.0
            R[R == 0] = 1e-5
            # camera = 'JPG'
            # Denoised by linear bluring
            if self.blur_mode:
                R = cv2.blur(R, (7,7))

            # mask bright-pixel
            if self.bright_occ_mode:
                bright_mask = self.generate_mask(R)
                idx1, idx2, _ = np.where(bright_mask == False)
                R[idx1, idx2, :] = 1e-5
            
        # RAW Preprocess Road
        else: 
            img = np.load(img_path + '.npy').astype(np.float32)[:,:,::-1]
            mask = np.load(img_path + '_mask.npy').astype(np.bool)
            ill = np.load(img_path + '_gt.npy').astype(np.float32)
            camera = str(np.load(img_path + '_camera.npy'))
            dynamic = self.dynamic[camera]
            # preprocess raw
            img = img / np.max(img) * 65535.0
            idx1, idx2, _ = np.where(mask == False)
            
            img[idx1, idx2, :] = 1e-5
            img[img == 0] = 1e-5
            R = self.process_LRC(img, ill, dynamic)

            if self.blur_mode:
                R = cv2.blur(R, (7,7))
       
        remove_stat, stat = self.process_R(R)
        
        if self.mode == 'train':
            img_batch = []
            gt_batch = []
            for i in range(self.AUG_NUM):
                if camera == 'JPG':
                    scale = math.exp(random.random()*math.log(self.JPG_SCALE[1] / self.JPG_SCALE[0])) * self.JPG_SCALE[0]
                else:
                    scale = math.exp(random.random()*math.log(self.RAW_SCALE[1] / self.RAW_SCALE[0])) * self.RAW_SCALE[0]
                img_aug, gt_aug = self.augment_train(remove_stat, stat, scale)
                img_aug = img_aug / 65535
                img_aug = Brightness_Correction(img_aug)
                img_batch.append(img_aug)
                gt_batch.append(gt_aug)
            img = np.stack(img_batch)
            gt = np.stack(gt_batch)
            # img = img / 65535
            img = np.power(img,(1.0/2.2))
            img = img.transpose(0,3,1,2)
            camera_onehot = self.camera2onehot(camera, self.AUG_NUM)
        else:
            gt = stat
            remove_stat = cv2.resize(remove_stat, (self.input_size, self.input_size))
            img = remove_stat / 65535
            img = Brightness_Correction(img)
            img = np.power(img,(1.0/2.2))
            img = img.transpose(2,0,1)
            camera_onehot = self.camera2onehot(camera, 1)
        img = torch.from_numpy(img.copy())
        gt = torch.from_numpy(gt.copy())
        # ill = torch.from_numpy(ill.copy())
        return img, gt # , camera, ill 

    def three_fold(self, idx):
        img_list = []
        dataset_lst = []
      
        if self.mode == 'train':
            if self.dataset_name in ['all', 'NJPG']:
                dataset_lst = ['NUS', 'CC']
            elif self.dataset_name in ['NUS', 'CC', 'Cube', 'Canon1DsMkIII']:
                dataset_lst = [self.dataset_name]
            else:
                pass
            for ds in dataset_lst:
                for i in range(3):
                    if i == idx:
                        continue
                    img_list += self.load_nameseq(self.data_dir + '/{}_half_fold{}.txt'.format(ds, i))
        else:
            if self.dataset_name in ['NUS', 'CC', 'Cube', 'Canon1DsMkIII']:
                img_list += self.load_nameseq(self.data_dir + '/{}_half_fold{}.txt'.format(self.dataset_name, idx))
        # Mix JPG data  
        if self.dataset_name in ['all', 'JPG']:
            if self.mode == 'train':
                jpg_lst = self.load_nameseq(self.data_dir + '/NPlace205_train.txt')
                random.shuffle(jpg_lst)
                raw_len = len(img_list)
                if raw_len > 0:
                    jpg_lst = jpg_lst[:int(raw_len*1/3)]
            else:
                jpg_lst = self.load_nameseq(self.data_dir + '/NPlace205_valid.txt')
        
            img_list += jpg_lst
        return img_list
        
    def augment_train(self, ldr, illum, scale):
        angle = (random.random() - 0.5) * self.ANGLE
        # scale = math.exp(random.random() * math.log(self.SCALE[1] / self.SCALE[0])) * self.SCALE[0]
        s = int(round(min(ldr.shape[:2]) * scale))
        s = min(max(s, 10), min(ldr.shape[:2]))
        start_x = random.randrange(0, ldr.shape[0] - s + 1)
        start_y = random.randrange(0, ldr.shape[1] - s + 1)        
        flip_lr = random.randint(0, 1) # Left-right flip?   
        color_aug = np.zeros(shape=(3, 3))
        for i in range(3):
            color_aug[i, i] = 1 + random.random() * self.AUG_COLOR - 0.5 * self.AUG_COLOR 
        
        def crop(img, illumination):
            if img is None:
                return None
            img = img[start_x:start_x + s, start_y:start_y + s]
            img = rotate_and_crop(img, angle)
            img = cv2.resize(img, (self.input_size, self.input_size))
            if flip_lr:
                img = img[:, ::-1]
            img = img.astype(np.float32)
            new_illum = np.zeros_like(illumination)
            for i in range(3):
                for j in range(3):
                    new_illum[i] += illumination[j] * color_aug[i, j]

            img *= np.array([[[color_aug[0][0], color_aug[1][1], color_aug[2][2]]]],dtype=np.float32)
            new_image = img
            new_image = np.clip(new_image, 0, 65535)
            new_illum = np.clip(new_illum, 0.01, 100)        
            return new_image, new_illum            
        return crop(ldr, illum)
